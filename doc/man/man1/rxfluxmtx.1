.\" RCSid "$Id$"
.TH RXFLUXMTX 1 10/23/2025 RADIANCE
.SH NAME
rxfluxmtx - compute flux transfer matrix(es) for RADIANCE scene
.SH SYNOPSIS
.B rxfluxmtx
[
.B \-W
] [
.B "rcontrib options"
]
.B "{ sender.rad | view | - }"
.B receivers.rad
.B "[ -i system.oct ]"
.B "[ system.rad .. ]"
.SH DESCRIPTION
.I rxfluxmtx
samples rays uniformly over the surface given in
.I sender.rad
and records rays arriving at surfaces in the file
.I receivers.rad,
producing a flux transfer matrix per receiver.
A system octree to which the receivers will be appended may be given with a
.I \-i
option following the receiver file.
Additional system surfaces may be given in one or more
.I system.rad
files, which are compiled before the receiver file into an octree used
to perform the simulation.
.PP
If a single hyphen ('-') is given in place of the view or sender file, then
.I rxfluxmtx
computes matrix rows based upon the provided ray sample origins and directions,
which may be surface normals if the
.I \-I+
option is applied.
The
.I \-y
option is required to specify the number of output rows for pass-through mode.
.PP
Alternatively, a view specification may be given on the command-line
to produce coefficient picture output, in which case both the
.I \-x
and
.I \-y
options must be present to set the desired picture dimensions.
The related
.I \-pj,
.I \-pd,
and
.I \-pa
options may be used to set the pixel jitter, depth-of-field, and
aspect ratio, respectively.
This avoids the need to call
.I vwrays(1),
as required by
.I rfluxmtx.
.PP
The
.I \-W+
option turns on verbose mode, and the
.I \-t
option sets the number of seconds between progress reports, similar to
.I rcontrib(1).
However, the
.I rcontrib
options
.I \-p,
.I \-b,
.I \-bn,
.I \-m,
and
.I \-M
options are controlled by
.I rxfluxmtx
and may not be set by the user.
.PP
The sample count, unless set by the
.I \-c
option, defaults to 10000 when a sender file is given, or to 1 for 
view and pass-through modes.
.SH VARIABLES
The sender and receiver scene files given to
.I rxfluxmtx
contain controlling parameters in special comments of the form:
.nf

	#@rxfluxmtx variable=value ..
or:
	#@rfluxmtx variable=value ..

.fi
At minimum, both sender and receiver must specify one of the
hemisphere sampling types, and there must be at least
one surface in each file.
.TP 10n
.BI h =u
Set hemisphere sampling to "uniform," meaning a single bin
of (cosine-distributed) samples.
In the case of distant "source" primitives, this is the only
sampling method that supports arbitrary receiver sizes.
The other methods below require a full hemispherical source.
.TP
.BI h =kf
Divide the hemisphere using the LBNL/Klems "full" sampling basis.
(Use "h=-kf" for left-handed coordinates.)
.TP
.BI h =kh
Divide the hemisphere using the LBNL/Klems "half" sampling basis.
(Use "h=-kh" for left-handed coordinates.)
.TP
.BI h =kq
Divide the hemisphere using the LBNL/Klems "quarter" sampling basis.
(Use "h=-kq" for left-handed coordinates.)
.TP
.BI h =rN
Divide the hemisphere using Reinhart's substructuring of the Tregenza
sky pattern with
.I N
divisions in each dimension.
If it is not given,
.I N
defaults to 1, which is just the Tregenza sky.
(Use "h=-rN" for left-handed coordinates.)
.TP
.BI h =cie
Divide the hemisphere into CIE sky scanner directions, which is
similar to Tregenza but with different starting azimuths and
reversing row direction at each new altitude.
(Use "h=-cie" for left-handed coordinates.)
.TP
.BI h =scN
Subdivide the hemisphere using the Shirley-Chiu square-to-disk mapping with an
.I NxN
grid over the square.
(Use "h=-scN" for left-handed coordinates.)
.TP
.BI u =[-]{X|Y|Z|ux,uy,uz}
Orient the "up" direction for the hemisphere using the indicated axis or direction
vector.
.TP
.BI o =output_spec
Send the matrix data for this receiver to the indicated file specification.
Single or double quotes may be used to contain strings with spaces, and
the usual "%s" and "%d" formats incorporate the modifier name and/or
bin number, as with
.I rcontrib.
Command (piped) output is not supported.
.PP
If no output_spec directive is given, it must be specified by a
.I \-o
setting on the command-line, since output to stdout is not supported.
The input and output file formats are controlled by the
.I \-fio
option, which may use a single letter for identical i/o formats.
The input format matters only in pass-through mode, for which
ASCII input is supported.
ASCII output is unsupported, since it interferes with
efficient recovery in the
.I \-r
mode.
The default setting is
.I \-faf.
.PP
In normal execution, only a single sender surface is sampled, but it may be
comprised of any number of subsurfaces, as in a triangle mesh or similar.
The surface normal will be computed as the average of all the constituent
subsurfaces.
The subsurfaces themselves must be planar, thus only
.I polygon
and
.I ring
surface primitives are supported.
Other primitives will be silently ignored and will have no effect on the calculation.
.PP
In the receiver file, the
.I source
primitive is supported as well, and multiple receivers (and multiple output
matrices) may be identified by different modifier names.
(Make sure that surfaces using the same modifier are grouped together,
and that the modifiers are unique and not used elsewhere in the
scene description.)\0
Though it may be counter-intuitive, receivers are often light sources,
since samples end up there in a backwards ray-tracing system such as RADIANCE.
When using local geometry, the overall aperture shape should be close to flat.
Large displacements may give rise to errors due to a convex receiver's
larger profile at low angles of incidence.
.PP
Rays always emanate from the back side of the sender surface and arrive at the
front side of receiver surfaces.
In this way, a receiver surface may be reused as a sender in a subsequent
.I rxfluxmtx
calculation and the resulting matrices will concatenate properly.
(Note that it is important to keep receiver surfaces together, otherwise a
"duplicate modifier" error will result.)\0
.SH EXAMPLES
To generate a flux transfer matrix connecting input and output apertures
on a light pipe:
.IP "" .2i
rxfluxmtx int_aperture.rad ext_aperture.rad lpipe.rad > lpipe.mtx
.PP
To generate a set of DC view component pictures with 9 jittered samples/pixel:
.IP "" .2i
rxfluxmtx -vf v1.vf -x 512 -y 512 -c 9 -pj .8 -fc reinhart_M4.rad -i scene1.oct
.PP
To compute a workplane irradiance matrix for each window in a space:
.IP "" .2i
rxfluxmtx -faf - windows_kf.rad -i scene2.oct < workplane_pts.txt
.SH NOTES
The main differences between
.I rfluxmtx(1)
and
.I rxfluxmtx
is that the latter does not run a separate
.I rcontrib
process.
Instead, it relies on a unix-only C++ class definition that offers full
control over i/o.
This allows an unlimited number of receivers, a
.I \-r
recovery option, and simplifies internal operations.
.SH AUTHOR
Greg Ward
.SH "SEE ALSO"
genBSDF(1), getinfo(1), pvsum(1), rcalc(1), rcollate(1), rcomb(1), rcontrib(1),
rcrop(1), rfluxmtx(1), rmtxop(1), vwrays(1), wrapBSDF(1)
